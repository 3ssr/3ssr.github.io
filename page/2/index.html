<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="记录打怪升级之路">
<meta property="og:type" content="website">
<meta property="og:title" content="个人博客">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="记录打怪升级之路">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="个人博客">
<meta name="twitter:description" content="记录打怪升级之路">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/">





  <title>个人博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/04/2018-09-06-tcp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="嘿嘿嘿">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://s2.ax1x.com/2019/08/14/mFInYj.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/04/2018-09-06-tcp/" itemprop="url">TCP协议</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-04T00:00:00+08:00">
                2018-09-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.8k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  6
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><p>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。在简化的计算机网络OSI模型中，它完成第四层传输层所指定的功能，用户数据报协议（UDP）是同一层内另一个重要的传输协议。</p>
<h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><ul>
<li>面向连接</li>
<li>一对一</li>
<li>可靠交付</li>
<li>全双工</li>
<li>面向字节流</li>
</ul>
<h3 id="套接字Socket的含义"><a href="#套接字Socket的含义" class="headerlink" title="套接字Socket的含义"></a>套接字Socket的含义</h3><ul>
<li>Socket := IP + Port</li>
<li>TCP连接 ：= {Socket1, Socket2} 解释为两个Socket之间的连接</li>
</ul>
<h3 id="TCP可靠传输的工作原理"><a href="#TCP可靠传输的工作原理" class="headerlink" title="TCP可靠传输的工作原理"></a>TCP可靠传输的工作原理</h3><ul>
<li><p>停止等待协议</p>
<ul>
<li>超时重传</li>
<li>超时计时器</li>
<li>保留已发送分组的副本</li>
<li>对数据分组和确认分组的编号</li>
<li>重传时间的设置</li>
<li>确认丢失和确认迟到</li>
<li>信道利用率</li>
</ul>
</li>
<li><p>连续ARQ协议</p>
<ul>
<li><p>发送方维持的滑动窗口</p>
</li>
<li><p>累计确认</p>
<ul>
<li><p>容易实现，即使确认丢失也不必重传</p>
</li>
<li><p>不能向发送方反映出接收方以及正确接收到的所有分组的信息</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="TCP报文段的首部格式"><a href="#TCP报文段的首部格式" class="headerlink" title="TCP报文段的首部格式"></a>TCP报文段的首部格式</h3><ul>
<li><p>源端口和目的端口</p>
</li>
<li><p>序号</p>
</li>
<li><p>确认号ack</p>
</li>
<li><p>数据偏移</p>
</li>
<li><p>保留位</p>
</li>
<li><p>紧急URG</p>
</li>
<li><p>确认位ACK(TCP连接过程中会用到)</p>
</li>
<li><p>推送PSH</p>
</li>
<li><p>复位RST</p>
</li>
<li><p>同步位SYN(在TCP连接过程中会用到)</p>
</li>
<li><p>终止FIN (在TCP释放过程中会用到)</p>
</li>
<li><p>窗口</p>
</li>
<li><p>检验和</p>
</li>
<li><p>紧急指针</p>
</li>
<li><p>选项</p>
<ul>
<li><p>最大报文长度MSS</p>
</li>
<li><p>窗口扩大</p>
</li>
<li><p>时间戳</p>
<ul>
<li><p>计算往返时间RTT</p>
</li>
<li><p>防止序号绕回</p>
</li>
</ul>
</li>
<li><p>选择确认</p>
</li>
</ul>
</li>
</ul>
<h3 id="TCP可靠传输的实现"><a href="#TCP可靠传输的实现" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h3><ul>
<li><p>滑动窗口</p>
<ul>
<li><p>以字节为单位的</p>
</li>
<li><p>结构划分</p>
<ul>
<li><p>已发送并收到确认部分</p>
</li>
<li><p>可发送部分</p>
</li>
<li><p>不允许发送部分</p>
</li>
</ul>
</li>
<li><p>发送窗口</p>
<ul>
<li><p>描述发送窗口状态的三个指针</p>
<ul>
<li><p>P1指向第一个已发送但未收到确认的字节的序号</p>
</li>
<li><p>P2指向第一个允许发送但尚未发送的字节的序号</p>
</li>
<li><p>P3指向第一个不允许发送的字节的序号</p>
</li>
</ul>
</li>
<li><p>P3 - P1 通知窗口</p>
</li>
<li><p>P2 - P1 已发送但尚未收到确认的字节数</p>
</li>
<li><p>P3 - P2 允许发送但尚未发送的字节数</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>超时重传</p>
<ul>
<li><p>TCP采用了一种自适应算法，该方法还在逐渐改进中</p>
</li>
<li><p>算法中声明的相关变量</p>
<ul>
<li><p>RTT(Round-Trip Time) 往返时间</p>
</li>
<li><p>RTT的加权平均往返时间RTTs</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>    * RTO(RetransmissionTime-Out)超时重传时间

    * RTTd(RTT的偏差的加权平均值)

* 相关公式

    * 新的RTTs = (1 - a) * (旧的RTTs) + a * (新的RTT样本)，a推荐取值0.125

    * RTO = RTTs + 4 * RTTd

    * RTTd = (1 - b) * (旧的RTTd) + b * |RTTs - 新的RTT样本|， b的推荐值是0.25

* 如何确定确认报文是对先发送的报文段的确认，还是对后来重传的报文段的确认？

    * Kran算法

    * 算法的改进

* 选择确认SACK（Selective ACK）

    * 目的： 只传输缺少的数据而不重传已经正确到达接收方的数据

    * 前提：建立TCP连接时，需要在首部选项中加上“允许SACK”的选项</code></pre><ul>
<li><p>流量控制</p>
<ul>
<li><p>接收窗口(rwnd)变化</p>
</li>
<li><p>持续计时器 + 零窗口探测报文段（解决非零窗口通知丢失造成死锁）</p>
</li>
<li><p>发送方缓存控制</p>
<ul>
<li><p>缓存达到MSS(最大报文段长度)后发送</p>
</li>
<li><p>发送方应用程序指明要求发送报文段</p>
</li>
<li><p>发送方的一个计时器期限到了</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>拥塞控制</p>
<p>  只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数</p>
<ul>
<li><p>原理</p>
</li>
<li><p>几种拥塞的控制方法</p>
<ul>
<li><p>慢开始</p>
<p> 当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。因此，较好的方法是 先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。每经过一个传输轮次，拥塞窗口 cwnd 就加倍。一个传输轮次所经历的时间其实就是往返时间RTT。不过“传输轮次”更加强调：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。另，慢开始的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd=1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大cwnd。</p>
</li>
<li><p>拥塞避免</p>
</li>
<li><p>快重传</p>
</li>
<li><p>快恢复</p>
</li>
</ul>
</li>
<li><p>如何确定网络发生了拥塞？ 答：只要发送方没有按时收到应当到达的确认报名，就可以猜想网络可能出现问题了</p>
</li>
</ul>
</li>
</ul>
<h3 id="运输连接管理"><a href="#运输连接管理" class="headerlink" title="运输连接管理"></a>运输连接管理</h3><ul>
<li><p>三次握手建立连接</p>
<ul>
<li><p>建立连接的过程</p>
<p>  <img src="https://s1.ax1x.com/2018/09/02/PzpWX8.png" alt="此处输入图片的描述"></p>
</li>
<li><p>涉及状态</p>
<ul>
<li><p>CLOSED</p>
</li>
<li><p>LISTEN</p>
</li>
<li><p>SYN-SENT 同步已发送</p>
</li>
<li><p>SYN-RCVD 同步确认</p>
</li>
<li><p>ESTABLISHED 连接建立</p>
</li>
</ul>
</li>
<li><p>涉及状态位</p>
<ul>
<li><p>SYN 同步位，置1代表请求连接</p>
</li>
<li><p>ACK 确认位，置1代表确认收到</p>
</li>
<li><p>seq 序号</p>
</li>
<li><p>ack 确认号</p>
</li>
</ul>
</li>
<li><p>为什么需要三次握手？最后A还需要再确认一次？</p>
<ul>
<li>为了防止已经失效的连接请求报文段传送到了B</li>
</ul>
</li>
</ul>
</li>
<li><p>四次挥手连接释放</p>
<ul>
<li><p>释放连接的过程</p>
<p>  <img src="https://s1.ax1x.com/2018/09/02/Pz9kjK.png" alt="此处输入图片的描述"></p>
</li>
<li><p>涉及状态</p>
<ul>
<li><p>ESTABLISHED</p>
</li>
<li><p>FIN-WAIT-1 A请求关闭，但还没有收到B的确认</p>
</li>
<li><p>CLOSE-WAIT B收到了关闭请求，并且进行了确认，但是还有数据需要传送给A</p>
</li>
<li><p>FIN_WAIT-2 A收到了B的确认，但B的数据还没发送完，A还需要接收数据</p>
</li>
<li><p>LAST-ACK B没有数据要发送了，请求关闭连接</p>
</li>
<li><p>TIME-WAIT A收到了关闭请求，并确认</p>
</li>
<li><p>CLOSED B收到了A的关闭确认，A等待2MSL之后</p>
</li>
</ul>
</li>
<li><p>涉及状态位</p>
<ul>
<li>FIN 终止控制位，置1代表请求关闭连接</li>
<li>ACK</li>
<li>ack</li>
<li>seq</li>
</ul>
</li>
<li><p>时间等待计时器</p>
<ul>
<li><p>MSL 最长报文段寿命</p>
</li>
<li><p>为什么最后A要等2MSL?</p>
<ul>
<li>为了保证最后确认能被B收到，如果B没收到，B会超时重发关闭请求，如果A此时直接CLOSED了，就无法接受该请求</li>
</ul>
</li>
</ul>
</li>
<li><p>保活计时器</p>
<ul>
<li><p>作用：防止客户端发生故障时，服务器空等请求</p>
</li>
<li><p>每次接收请求时更新</p>
</li>
<li><p>2小时无响应，就每75分钟发送一个探测报文段，连发10次确认客户端是否出现故障</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/04/2018-09-05-gulp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="嘿嘿嘿">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://s2.ax1x.com/2019/08/14/mFInYj.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/04/2018-09-05-gulp/" itemprop="url">Gulp</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-04T00:00:00+08:00">
                2018-09-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Gulp-杂记"><a href="#Gulp-杂记" class="headerlink" title="Gulp 杂记"></a>Gulp 杂记</h1><h3 id="什么是-gulp"><a href="#什么是-gulp" class="headerlink" title="什么是 gulp?"></a>什么是 gulp?</h3><p>gulp 是一个构建工具，可以通过它自动执行网站开发过程中的公共任务，比如编译 SASS/Less，编译压缩混淆 JavaScript,，合并编译模板和版本控制等。因为 gulp 是基于 Node.js 构建的，所以 gulp 源文件和开发者自己定义的 gulpfile 都被写进 JavaScript 里，前端开发者可以用自己熟悉的语言来编写 gulp 任务。</p>
<p>gulp 本身并不能完成这么多种任务，不过它可以借助 npm 丰富的插件库。开发者可以在 npm 中搜索 gulpplugin 找到想要的插件。例如本文中将要提到的 gulp-cssmin, gulp-jshint, gulp-concat、gulp-inject 等等。</p>
<h3 id="为什么选择-gulp？"><a href="#为什么选择-gulp？" class="headerlink" title="为什么选择 gulp？"></a>为什么选择 gulp？</h3><p>其实现有的基于 Node.js 的构建工具有很多，比如 Bower，Yeoman，grunt 等。而且自 2013 年 grunt v0.4.0 发布以后，grunt 已经改变了前端的开发方式。那么为什么我们要选 gulp？</p>
<p>gulp 最大的特点是所有的任务都是以 Node.js Stream 的形式处理，构建流程可以由 Stream 之间的 pipe 来定义，省去了把中间文件写到磁盘再读取的过程，而且任务都是默认并行，速度比 grunt 快很多，配置也感觉更省心。</p>
<ul>
<li>易于使用：采用代码优于配置策略，gulp 让简单的事情继续简单，复杂的任务变得可管理。</li>
<li>高效：gulp 基于 Node.js 流 Unix 管道连接的方式，不需要往磁盘写中间文件，可以更快地完成构建。</li>
<li>高质量：gulp 每个 task 只完成一个任务，提高 task 的重用度。</li>
<li>易于学习：gulp 核心 API 约 5 个，开发者能在很短的时间内学会，之后就可以通过管道流来组合自己需要的 task。</li>
</ul>
<h3 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h3><ol>
<li><p>创建项目，初始化package.json文件，并安装gulp作为开发依赖</p>
<blockquote>
<p>$ mkdir gulp-app &amp;&amp; npm init<br>$ npm install –save-dev gulp</p>
</blockquote>
</li>
<li><p>新建gulpfile.js文件，并写入以下内容</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var gulp = require(&apos;gulp&apos;)</span><br><span class="line"></span><br><span class="line">gulp.task(&apos;default&apos;, () =&gt; &#123;</span><br><span class="line">    console.log(&apos;what the hell&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>命令行执行gulp，会看到输出 ‘what the hell’</p>
</li>
</ol>
<h3 id="gulp几个重要的api"><a href="#gulp几个重要的api" class="headerlink" title="gulp几个重要的api"></a>gulp几个重要的api</h3><h3 id="构建自动化流程"><a href="#构建自动化流程" class="headerlink" title="构建自动化流程"></a>构建自动化流程</h3><p>gulp提供了许多可以满足我们工作需求的插件，以下列举部分：</p>
<ul>
<li><p><a href="https://www.npmjs.com/package/gulp-uglify" title="gulp-uglify" target="_blank" rel="noopener">gulp-uglify</a></p>
<ul>
<li><p>安装</p>
<blockquote>
<p>$ npm install –save-dev gulp-uglify</p>
</blockquote>
</li>
<li><p>配置task</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(&apos;default&apos;, () =&gt; &#123;</span><br><span class="line">  gulp</span><br><span class="line">  .src(&apos;src/app.js&apos;)</span><br><span class="line">  .pipe(uglify())</span><br><span class="line">  .pipe(gulp.dest(&apos;dist&apos;))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><a href="https://www.npmjs.com/package/gulp-less" title="gulp-less" target="_blank" rel="noopener">gulp-less</a></p>
<ul>
<li><p>安装</p>
<blockquote>
<p>$ npm install –save-dev gulp-less</p>
</blockquote>
</li>
<li><p>配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var less = require(&apos;gulp-less&apos;)</span><br><span class="line"></span><br><span class="line">gulp.task(&apos;default&apos;, () =&gt; &#123;</span><br><span class="line">  gulp.src(&apos;src/styles/app.less&apos;)</span><br><span class="line">  .pipe(less())</span><br><span class="line">  .pipe(gulp.dest(&apos;dist/styles&apos;))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><a href="https://www.npmjs.com/package/gulp-coffee" title="gulp-coffee" target="_blank" rel="noopener">gulp-coffee</a></p>
<ul>
<li><p>安装</p>
<blockquote>
<p>$ npm install –save-dev gulp-coffee</p>
</blockquote>
</li>
<li><p>配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var coffee = require(&apos;gulp-coffee&apos;)</span><br><span class="line"></span><br><span class="line">gulp.task(&apos;default&apos;, () =&gt; &#123;</span><br><span class="line">  gulp.src(&apos;src/scripts/app.coffee&apos;).pipe(coffee()).pipe(gulp.dest(&apos;dist/scripts&apos;))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><a href="https://www.npmjs.com/package/gulp-clean" title="gulp-clean" target="_blank" rel="noopener">gulp-clean</a></p>
<ul>
<li><p>安装</p>
<blockquote>
<p>$ npm install –save-dev gulp-clean</p>
</blockquote>
</li>
<li><p>配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var clean = require(&apos;gulp-clean&apos;)</span><br><span class="line"></span><br><span class="line">gulp.task(&apos;clean&apos;, () =&gt; &#123;</span><br><span class="line">  gulp.src(&apos;dist/&apos;).pipe(clean())</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><a href="https://www.npmjs.com/package/gulp-autoprefixer" title="autoprefixer" target="_blank" rel="noopener">gulp-autoprefixer</a></p>
<ul>
<li><p>安装</p>
<blockquote>
<p>$ npm install –save-dev gulp-autoprefixer</p>
</blockquote>
</li>
<li><p>配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var autoPrefixer = require(&apos;gulp-autoprefixer&apos;)</span><br><span class="line"></span><br><span class="line">gulp.task(&apos;css&apos;, () =&gt; &#123;</span><br><span class="line">  gulp.src(&apos;src/styles/app.less&apos;).pipe(less()).pipe(autoPrefixer()).pipe(gulp.dest(&apos;dist/styles&apos;))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><a href="http://www.gulpjs.com.cn/docs/recipes/server-with-livereload-and-css-injection/" target="_blank" rel="noopener">browser-sync</a> 拥有实时重载（live-reloading）和 CSS 注入的服务器</p>
<ul>
<li><p>安装</p>
<blockquote>
<p>$ npm install –save-dev browser-sync</p>
</blockquote>
</li>
<li><p>配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">var gulp = require(&apos;gulp&apos;)</span><br><span class="line">var uglify = require(&apos;gulp-uglify&apos;)</span><br><span class="line">var less = require(&apos;gulp-less&apos;)</span><br><span class="line">var coffee = require(&apos;gulp-coffee&apos;)</span><br><span class="line">var clean = require(&apos;gulp-clean&apos;)</span><br><span class="line">var autoPrefixer = require(&apos;gulp-autoprefixer&apos;)</span><br><span class="line">var browserSync = require(&apos;browser-sync&apos;);</span><br><span class="line">var reload = browserSync.reload;</span><br><span class="line"></span><br><span class="line">gulp.task(&apos;clean&apos;, () =&gt; &#123;</span><br><span class="line">  gulp.src(&apos;dist/&apos;).pipe(clean())</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">gulp.task(&apos;coffee&apos;, () =&gt; &#123;</span><br><span class="line">  gulp.src(&apos;src/scripts/*.coffee&apos;)</span><br><span class="line">  .pipe(coffee())</span><br><span class="line">  .pipe(uglify())</span><br><span class="line">  .pipe(gulp.dest(&apos;dist/scripts&apos;))</span><br><span class="line">  // .pipe(reload(&#123; stream: true &#125;))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">gulp.task(&apos;less&apos;, () =&gt; &#123;</span><br><span class="line">  gulp.src(&apos;src/styles/app.less&apos;)</span><br><span class="line">  .pipe(less())</span><br><span class="line">  .pipe(autoPrefixer())</span><br><span class="line">  .pipe(gulp.dest(&apos;dist/styles&apos;))</span><br><span class="line">  .pipe(reload(&#123; stream: true &#125;))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 监视文件改动并重新载入</span><br><span class="line">gulp.task(&apos;serve&apos;, function() &#123;</span><br><span class="line">  browserSync(&#123;</span><br><span class="line">    server: &#123;</span><br><span class="line">      baseDir: &apos;./&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  gulp.watch(&apos;src/styles/app.less&apos;, [&apos;less&apos;]);</span><br><span class="line">  gulp.watch(&apos;src/scripts/app.coffee&apos;, [&apos;coffee&apos;])</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(&apos;default&apos;,[&apos;clean&apos;, &apos;coffee&apos;, &apos;less&apos;, &apos;serve&apos;])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/04/2018-09-04-grunt/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="嘿嘿嘿">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://s2.ax1x.com/2019/08/14/mFInYj.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/04/2018-09-04-grunt/" itemprop="url">Grunt</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-04T00:00:00+08:00">
                2018-09-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.1k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Grunt-杂记"><a href="#Grunt-杂记" class="headerlink" title="Grunt 杂记"></a>Grunt 杂记</h1><p><img src="https://img.shields.io/badge/js-grunt-brightgreen.svg" alt="grunt"></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Grunt是一个基于NodeJS，可用于自动化构建、测试、生成文档的项目管理工具。</p>
<h3 id="Grunt-能做什么"><a href="#Grunt-能做什么" class="headerlink" title="Grunt 能做什么"></a>Grunt 能做什么</h3><p>Grunt可以自动化我们的整个开发流程，简单地说，就是用JavaScript去执行一些程序来完成一些任务。比如说将css、Javascript、图像等资源压缩；将Sass和Less通过预处理器编译成Css；将Coffeescript、Typescript等转化为Javascript；实时监听文件的变化，并执行自动编译任务；</p>
<p>在Grunt工具箱中，按任务目标我们可以分为：</p>
<ul>
<li>编译文档型：比如编译LESS、Sass、Stylus、Coffeescript等；</li>
<li>文件操作型：比如说合并、压缩JavaScript、CSS、图片等；</li>
<li>质量保障型：比如JSHint、Jasmin、Mocha等；</li>
<li>类库构建型：比如说Backbone.js、ember.js、angular.js等。</li>
</ul>
<p>这些任务都依赖于给Grunt提供的插件来完成的，但很多工作依旧需要在命令终端手工输入命令来完成这些操作。为此在Grunt中可以使用watch任务来实现一些监听文件改变、自动触发构建等功能。从而减少人工去每次操作任务。</p>
<h3 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h3><p>Grunt的使用非常简单，仅需下载相应的命令行工具，针对不同的任务下载不同的插件，即可完成整个自动化过程。</p>
<ul>
<li><p>将grunt-cli（grunt命令行工具）作为全局模块安装</p>
<blockquote>
<p>$ npm install -g grunt-cli</p>
</blockquote>
</li>
<li><p>通过npm初始化，为我们生成一份package.json文件</p>
<blockquote>
<p>$ mkdir grunt-app &amp;&amp; cd grunt-app<br>$ npm init</p>
</blockquote>
</li>
<li><p>为项目安装grunt作为依赖</p>
<blockquote>
<p>$ npm install –save-dev grunt</p>
</blockquote>
<p>  至此grunt已经安装完毕，但它还没有特殊的功能，要使用grunt的各种功能，需要建一份Gruntfile.js文件，并为之安装相应的插件。</p>
</li>
<li><p>新建Gruntfile.js，并写入以下内容</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function(grunt) &#123;</span><br><span class="line"></span><br><span class="line">  // 之后所有的配置都是配在传递给grunt.initConfig这个方法的对象中</span><br><span class="line">  grunt.initConfig(&#123;</span><br><span class="line">    // 将package.json文件作为一个json对象读入</span><br><span class="line">    pkg: grunt.file.readJSON(&apos;package.json&apos;),</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // 加载grunt的插件，这里的 grunt-contrib-uglify 是一个例子</span><br><span class="line">  grunt.loadNpmTasks(&apos;grunt-contrib-uglify&apos;);</span><br><span class="line"></span><br><span class="line">  // 注册一个grunt任务，第一个参数为任务的名字，当任务的名字default时，通过grunt运行项目时，会默认执行该任务；第二个参数是一个数组，是后续所要执行任务名字的集合。</span><br><span class="line">  grunt.registerTask(&apos;default&apos;, [&apos;uglify&apos;]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="安装grunt插件"><a href="#安装grunt插件" class="headerlink" title="安装grunt插件"></a>安装grunt插件</h3><p>在安装grunt插件时，需要考虑自己需要哪些功能，下面罗列出开发中需要的大部分功能。并举个简单的例子，详细用法可参考 <a href="https://github.com/gruntjs" title="Gruntjs的github链接" target="_blank" rel="noopener">Gruntjs</a>。</p>
<ol>
<li><p><a href="https://github.com/gruntjs/grunt-contrib-uglify" title="grunt uglify" target="_blank" rel="noopener">grunt-contrib-uglify</a> （混淆并压缩js文件）</p>
<ul>
<li><p>安装</p>
<blockquote>
<p>$ npm install grunt-contrib-uglify –save-dev</p>
</blockquote>
</li>
<li><p>配置task</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">grunt.initConfig(&#123;</span><br><span class="line">    uglify: &#123;</span><br><span class="line">        my_target: &#123;</span><br><span class="line">          files: &#123;</span><br><span class="line">            &apos;dest/output.min.js&apos;: [&apos;src/input1.js&apos;, &apos;src/input2.js&apos;]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">grunt.loadNpmTasks(&apos;grunt-contrib-uglify&apos;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><a href="https://github.com/gruntjs/grunt-contrib-cssmin" title="grunt cssmin" target="_blank" rel="noopener">grunt-contrib-cssmin</a> （压缩css）</p>
<ul>
<li><p>安装</p>
<blockquote>
<p>$ npm install grunt-contrib-cssmin –save-dev</p>
</blockquote>
</li>
<li><p>配置task</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">grunt.initConfig(&#123;</span><br><span class="line">    target: &#123;</span><br><span class="line">        files: &#123;</span><br><span class="line">          &apos;output.css&apos;: [&apos;foo.css&apos;, &apos;bar.css&apos;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">grunt.loadNpmTasks(&apos;grunt-contrib-cssmin&apos;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><a href="https://github.com/gruntjs/grunt-contrib-clean" title="grunt clean" target="_blank" rel="noopener">grunt-contrib-clean</a> （清除文件和目录，一般用来清除上一次编译生成的文件）</p>
<ul>
<li><p>安装</p>
<blockquote>
<p>$ npm install grunt-contrib-clean –save-dev</p>
</blockquote>
</li>
<li><p>配置task</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">grunt.initConfig(&#123;</span><br><span class="line">    clean: &#123;</span><br><span class="line">        build: &#123;</span><br><span class="line">            src: [&apos;path/to/dir/one&apos;, &apos;path/to/dir/two&apos;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">grunt.loadNpmTasks(&apos;grunt-contrib-clean&apos;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><a href="https://github.com/gruntjs/grunt-contrib-watch" title="grunt watch" target="_blank" rel="noopener">grunt-contrib-watch</a> （监听文件的变化，并自动执行任务）</p>
<ul>
<li><p>安装</p>
<blockquote>
<p>$ npm install grunt-contrib-watch –save-dev</p>
</blockquote>
</li>
<li><p>配置task</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">grunt.initConfig(&#123;</span><br><span class="line">    watch: &#123;</span><br><span class="line">        scripts: &#123;</span><br><span class="line">            files: [&apos;**/*.coffee&apos;],</span><br><span class="line">            // 监听到文件变化后执行的task</span><br><span class="line">            tasks: [&apos;coffee&apos;],</span><br><span class="line">            options: &#123;</span><br><span class="line">                spawn: false,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        css: &#123;</span><br><span class="line">            files: &apos;**/*.sass&apos;,</span><br><span class="line">            tasks: [&apos;sass&apos;],</span><br><span class="line">            options: &#123;</span><br><span class="line">                livereload: true,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">grunt.loadNpmTasks(&apos;grunt-contrib-watch&apos;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><a href="https://github.com/gruntjs/grunt-contrib-connect" title="grunt connect" target="_blank" rel="noopener">grunt-contrib-connect</a> （开启一个服务器，使我们可以通过 <code>ip:端口号</code> 的方式访问目录下的资源）</p>
<ul>
<li><p>安装</p>
<blockquote>
<p>$ npm install grunt-contrib-connect –save-dev</p>
</blockquote>
</li>
<li><p>配置task</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">grunt.initConfig(&#123;</span><br><span class="line">    connect: &#123;</span><br><span class="line">        server: &#123;</span><br><span class="line">            options: &#123;</span><br><span class="line">                port: 9001,</span><br><span class="line">                base: &apos;www-root&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">grunt.loadNpmTasks(&apos;grunt-contrib-connect&apos;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><a href="https://github.com/gruntjs/grunt-contrib-less" title="grunt less" target="_blank" rel="noopener">grunt-contrib-less</a> （将less编译为css）</p>
<ul>
<li><p>安装</p>
<blockquote>
<p>$ npm install grunt-contrib-less –save-dev</p>
</blockquote>
</li>
<li><p>配置task</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">grunt.initConfig(&#123;</span><br><span class="line">    development: &#123;</span><br><span class="line">        files: &#123;</span><br><span class="line">            &apos;path/to/result.css&apos;: &apos;path/to/source.less&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">grunt.loadNpmTasks(&apos;grunt-contrib-less&apos;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><a href="https://github.com/gruntjs/grunt-contrib-coffee" title="grunt coffeescript" target="_blank" rel="noopener">grunt-contrib-coffee</a> （将coffeescript编译成javascript）</p>
<ul>
<li><p>安装</p>
<blockquote>
<p>$ npm install grunt-contrib-coffee –save-dev</p>
</blockquote>
</li>
<li><p>配置task</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">grunt.initConfig(&#123;</span><br><span class="line">    development: &#123;</span><br><span class="line">        files: &#123;</span><br><span class="line">            &apos;path/to/result.js&apos;: &apos;path/to/source.coffee&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">grunt.loadNpmTasks(&apos;grunt-contrib-coffee&apos;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/04/2018-09-06-udp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="嘿嘿嘿">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://s2.ax1x.com/2019/08/14/mFInYj.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/04/2018-09-06-udp/" itemprop="url">UDP协议</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-04T00:00:00+08:00">
                2018-09-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  218
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><p>UDP协议全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在第四层——传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。</p>
<ul>
<li><p>基本特点</p>
<ul>
<li><p>无连接的</p>
</li>
<li><p>不保证可靠交付</p>
</li>
<li><p>面向报文的，在添加了UDP协议的首部后就直接塞给UP层了</p>
</li>
<li><p>没有拥塞控制</p>
</li>
<li><p>支持一对一，一对多和多对多的交互通信</p>
</li>
<li><p>UDP首部开销小</p>
</li>
</ul>
</li>
<li><p>UDP首部格式</p>
<ul>
<li><p>源端口</p>
</li>
<li><p>目的端口</p>
</li>
<li><p>长度</p>
</li>
<li><p>校验和（检测UDP数据包在传输中是否有错，有错就丢弃）</p>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/02/2018-09-02-产生死锁的原因和必要条件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="嘿嘿嘿">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://s2.ax1x.com/2019/08/14/mFInYj.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/02/2018-09-02-产生死锁的原因和必要条件/" itemprop="url">产生死锁的原因和必要条件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-02T00:00:00+08:00">
                2018-09-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  771
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  2
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="产生死锁的原因和必要条件"><a href="#产生死锁的原因和必要条件" class="headerlink" title="产生死锁的原因和必要条件"></a>产生死锁的原因和必要条件</h2><p>在多道程序系统中，虽可借助于多个进程的并发执行来改善系统的资源利用率，提高系统的吞吐量，但可能发生一种危险——死锁。所谓死锁(Deadlock)，是指多个进程在运行过程中因争夺资源而造成的一种僵局(DeadlyEmbrace)，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。</p>
<h3 id="产生死锁的必要条件"><a href="#产生死锁的必要条件" class="headerlink" title="产生死锁的必要条件"></a>产生死锁的必要条件</h3><ul>
<li><p>互斥条件</p>
<p> 指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由<br>一个进程占用。如果此时还有其它进程请求该资源，则请求者只能等待，直至占有该资源的进程用毕释放。</p>
</li>
<li><p>请求和保持条件</p>
<p>  指进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</p>
</li>
<li><p>不剥夺条件</p>
<p>  指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完<br>时由自己释放。</p>
</li>
<li><p>环路等待条件</p>
<p>  指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，…，Pn}中的 P0正在等待一个 P1占用的资源； P1正在等待 P2占用的资源，……，Pn正在等待已被 P0占用的资源。</p>
</li>
</ul>
<h3 id="处理死锁的基本方法"><a href="#处理死锁的基本方法" class="headerlink" title="处理死锁的基本方法"></a>处理死锁的基本方法</h3><ul>
<li><p>预防死锁</p>
<p>  该方法是通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或几个条件，来预防发生死锁。预防死锁是一种较易实现的方法，已被广泛使用。但由于所施加的限制条件往往太严格，因而可能会导致系统资源利用率和系统吞吐量降低。</p>
</li>
<li><p>避免死锁</p>
<p>  是在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免发生死锁</p>
</li>
<li><p>检测死锁</p>
<p>  这种方法并不须事先采取任何限制性措施，也不必检查系统是否已经进<br>入不安全区，而是允许系统在运行过程中发生死锁。但可通过系统所设置的检测机构，及时地检测出死锁的发生，并精确地确定与死锁有关的进程和资源； 然后，采取适当措施，从系统中将已发生的死锁清除掉</p>
</li>
<li><p>解除死锁</p>
<p>  这是与检测死锁相配套的一种措施。当检测到系统中已发生死锁时，须<br>将进程从死锁状态中解脱出来。常用的实施方法是撤消或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/02/2018-09-01-操作系统引论/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="嘿嘿嘿">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://s2.ax1x.com/2019/08/14/mFInYj.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/02/2018-09-01-操作系统引论/" itemprop="url">操作系统引论</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-02T00:00:00+08:00">
                2018-09-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.4k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  8
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第一章-操作系统引论"><a href="#第一章-操作系统引论" class="headerlink" title="第一章 操作系统引论"></a>第一章 操作系统引论</h1><ul>
<li><p>操作系统的目标和作用</p>
<ul>
<li>OS 作为用户与计算机硬件系统之间的接口</li>
<li>OS 作为计算机系统资源(处理器、存储器、I/O 设备以及信息(数据和程序))的管理者</li>
<li>OS 实现了对计算机资源的抽象</li>
</ul>
</li>
<li><p>操作系统的基本特性</p>
<ul>
<li><p>并发性</p>
<p>   并行性是指两个或多个事件在同一时刻发生；而并发性是指两个或多个事件在同一时间间隔内发生。</p>
</li>
<li><p>共享性</p>
<p>   指系统中的资源可供内存中多个并发执行的进程(线程)共同使用</p>
<ul>
<li><p>虚拟技术</p>
<ul>
<li>时分复用技术</li>
<li>空分复用技术</li>
</ul>
</li>
<li><p>异步性</p>
<p> 由于资源等因素的限制，使进程的执行通常都不是“一气呵成”，而是以“停停走走”的方式运行</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>操作系统的主要功能</p>
<ul>
<li><p><a href="#处理机管理功能">处理机管理功能</a></p>
<p>  在传统的多道程序系统中，处理机的分配和运行都是以进程为基本单位，因而对处理机的管理可归结为对进程的管理；在引入了线程的 OS 中，也包含对线程的管理。处理机管理的主要功能是创建和撤消进程(线程)，对诸进程(线程)的运行进行协调，实现进程(线程)之间的信息交换，以及按照一定的算法把处理机分配给进程(线程)。</p>
</li>
<li><p><a href="#存储器的功能">存储器的功能</a></p>
<p>  存储器管理应具有内存分配、内存保护、地址映射和内存扩充</p>
</li>
<li><p><a href="#设备管理功能">设备管理功能</a></p>
<p>  设备管理用于管理计算机系统中所有的外围设备，而设备管理的主要任务是：完成用户进程提出的 I/O 请求；为用户进程分配其所需的 I/O 设备；提高 CPU 和 I/O 设备的利用率；提高 I/O 速度；方便用户使用 I/O 设备。为实现上述任务，设备管理应具有缓冲管理、设备分配和设备处理以及虚拟设备等功能。</p>
</li>
<li><p><a href="#文件管理功能">文件管理功能</a></p>
<p> 文件管理的主要任务是对用户文件和系统文件进行管理，以方便用户使用，并保证文件的安全性。</p>
</li>
</ul>
</li>
</ul>
<h3 id="处理机管理功能"><a href="#处理机管理功能" class="headerlink" title="处理机管理功能"></a><span id="p1">处理机管理功能</span></h3><ul>
<li><p>进程控制</p>
<p>  进程控制的主要功能是为作业创建进程，撤消已结束的进程</p>
</li>
<li><p>进程同步</p>
<ul>
<li>进程互斥方式<br>  指诸进程(线程)在对临界资源进行访问时，应采用互斥方式；</li>
<li>进程同步方式<br>  指在相互合作去完成共同任务的诸进程(线程)间，由同步机构对它们的执行次序加以协调。</li>
</ul>
</li>
<li><p>进程通信</p>
<p>  进程通信的任务就是用来实现在相互合作的进程之间的信息交换。由源进程利用发送命令直接将消息(Message)挂到目标进程的消息队列上，以后由目标进程利用接收命令从其消息队列中取出消息</p>
</li>
<li><p>调度</p>
<ul>
<li>作业调度<br>  作业调度的基本任务是从后备队列中按照一定的算法，选择出若干个作业，为它们分配运行所需的资源(首先是分配内存)。在将它们调入内存后，便分别为它们建立进程，使它们都成为可能获得处理机的就绪进程，并按照一定的算法将它们插入就绪队列。</li>
<li>进程调度<br>  进程调度的任务是从进程的就绪队列中，按照一定的算法选出一个进程，把处理机分配给它，并为它设置运行现场，使进程投入执行。值得提出的是，在多线程OS中，通常是把线程作为独立运行和分配处理机的基本单位，为此，须把就绪线程排成一个队列，每次调度时，是从就绪线程队列中选出一个线程，把处理机分配给它。</li>
</ul>
</li>
</ul>
<h3 id="存储器的功能"><a href="#存储器的功能" class="headerlink" title="存储器的功能"></a><span id="p2">存储器的功能</span></h3><ul>
<li><p>内存分配</p>
<p>  主要任务是为每道程序分配内存空间</p>
<ul>
<li><p>静态分配</p>
<p>  静态分配方式中，每个作业的内存空间是在作业装入时确定的，的整个运行期间，不允许该作业再申请新的内存空间</p>
</li>
<li><p>动态分配</p>
<p>  每个作业所要求的基本内存空间也是在装入时确定的，但允许作业在运行过程中继续申请新的附加内存空间，以适应程序和数据的动态增长，也允许作业在内存中“移动”。</p>
<ul>
<li>内存分配数据结构。该结构用于记录内存空间的使用情况，作为内存分配的依据；</li>
<li>内存分配功能。系统按照一定的内存分配算法为用户程序分配内存空间；</li>
<li>内存回收功能。系统对于用户不再需要的内存，通过用户的释放请求去完成系统的回收功能。</li>
</ul>
</li>
</ul>
</li>
<li><p>内存保护</p>
<p>  内存保护的主要任务是确保每道用户程序都只在自己的内存空间内运行，彼此互不干扰；为了确保每道程序都只在自己的内存区中运行，必须设置内存保护机制。一种比较简单的内存保护机制是设置两个界限寄存器，分别用于存放正在执行程序的上界和下界。系统须对每条指令所要访问的地址进行检查，如果发生越界，便发出越界中断请求，以停止该程序的执行。</p>
</li>
<li><p>地址映射</p>
<p>  一个应用程序(源程序)经编译后，通常会形成若干个目标程序；这些目标程序再经过链接便形成了可装入程序。这些程序的地址都是从“0”开始的，程序中的其它地址都是相对于起始地址计算的。由这些地址所形成的地址范围称为“地址空间”，其中的地址称为“逻辑地址”或“相对地址”。</p>
</li>
<li><p>内存扩充</p>
<p>  存储器管理中的内存扩充任务并非是去扩大物理内存的容量，而是借助于虚拟存储技术，从逻辑上去扩充内存容量，使用户所感觉到的内存容量比实际内存容量大得多，以便让更多的用户程序并发运行。这样，既满足了用户的需要，又改善了系统的性能。为此，只需增加少量的硬件。为了能在逻辑上扩充内存，系统必须具有内存扩充机制，用于实现下述各功能：</p>
<ul>
<li><p>请求调入功能。允许在装入一部分用户程序和数据的情况下，便能启动该程序运行。在程序运行过程中，若发现要继续运行时所需的程序和数据尚未装入内存，可向OS发出请求，由OS从磁盘中将所需部分调入内存，以便继续运行。</p>
</li>
<li><p>置换功能。若发现在内存中已无足够的空间来装入需要调入的程序和数据时，系统应能将内存中的一部分暂时不用的程序和数据调至盘上，以腾出内存空间，然后再将所需调入的部分装入内存。</p>
</li>
</ul>
</li>
</ul>
<h3 id="设备管理功能"><a href="#设备管理功能" class="headerlink" title="设备管理功能"></a><span id="p3">设备管理功能</span></h3><ul>
<li><p>缓冲管理</p>
<p>  如果在 I/O 设备和 CPU之间引入缓冲，则可有效地缓和 CPU 与 I/O 设备速度不匹配的矛盾，提高 CPU 的利用率，进而提高系统吞吐量。</p>
</li>
<li><p>设备分配</p>
<p>  是根据用户进程的 I/O 请求、系统的现有资源情况以及按照某种设备的分配策略，为之分配其所需的设备。</p>
</li>
<li><p>设备处理</p>
<p>  其基本任务是用于实现 CPU 和设备控制器之间的通信，即由 CPU 向设备控制器发出 I/O 命令，要求它完成指定的 I/O 操作；反之，由 CPU接收从控制器发来的中断请求，并给予迅速的响应和相应的处理</p>
</li>
</ul>
<h3 id="文件管理功能"><a href="#文件管理功能" class="headerlink" title="文件管理功能"></a><span id="p4">文件管理功能</span></h3><ul>
<li><p>文件存储空间的管理</p>
<p>  为了方便用户的使用，对于一些当前需要使用的系统文件和用户文件，都必须放在可随机存取的磁盘上。在多用户环境下，若由用户自己对文件的存储进行管理，不仅非常困难，而且也必然是十分低效的。因而，需要由文件系统对诸多文件及文件的存储空间实施统一的管理。其主要任务是为每个文件分配必要的外存空间，提高外存的利用率，并能有助于提高文件系统的存、取速度。</p>
<p>  为此，系统应设置相应的数据结构，用于记录文件存储空间的使用情况，以供分配存储空间时参考；系统还应具有对存储空间进行分配和回收的功能。为了提高存储空间的利用率，对存储空间的分配，通常是采用离散分配方式，以减少外存零头，并以盘块为基本分配单位。盘块的大小通常为 1～8 KB。</p>
</li>
<li><p>目录管理</p>
</li>
<li><p>文件的读/写管理和保护</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/02/2018-09-02-分段存储管理方式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="嘿嘿嘿">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://s2.ax1x.com/2019/08/14/mFInYj.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/02/2018-09-02-分段存储管理方式/" itemprop="url">基本分段存储管理方式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-02T00:00:00+08:00">
                2018-09-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.6k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  8
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基本分段存储管理方式"><a href="#基本分段存储管理方式" class="headerlink" title="基本分段存储管理方式"></a>基本分段存储管理方式</h2><p>如果说推动存储管理方式从固定分区到动态分区分配，进而又发展到分页存储管理方式的主要动力，是提高内存利用率，那么，引入分段存储管理方式的目的，则主要是为了满足用户(程序员)在编程和使用上多方面的要求。</p>
<h3 id="分段存储管理方式的引入"><a href="#分段存储管理方式的引入" class="headerlink" title="分段存储管理方式的引入"></a>分段存储管理方式的引入</h3><ul>
<li><p>方便编程</p>
<p>  通常，用户把自己的作业按照逻辑关系划分为若干个段，每个段都是从 0 开始编址，并有自己的名字和长度。因此，希望要访问的逻辑地址是由段名(段号)和段内偏移量(段内地址)决定的。</p>
</li>
<li><p>信息共享</p>
<p>  在实现对程序和数据的共享时，是以信息的逻辑单位为基础的。比如，共享某个例程<br>和函数。分页系统中的“页”只是存放信息的物理单位(块)，并无完整的意义，不便于实现共享；然而段却是信息的逻辑单位。</p>
</li>
<li><p>信息保护</p>
</li>
<li><p>动态增长</p>
<p>  在实际应用中，往往有些段，特别是数据段，在使用过程中会不断地增长，而事先又无法确切地知道数据段会增长到多大。(是哪种情况?)</p>
</li>
<li><p>动态链接</p>
<p>  动态链接是指在作业运行之前，并不把几个目标程序段链接起来。要运行时，先将主程序所对应的目标程序装入内存并启动运行，当运行过程中又需要调用某段时，才将该段(目标程序)调入内存并进行链接。可见，动态链接也要求以段作为管理的单位。</p>
</li>
</ul>
<h3 id="分段系统的基本原理"><a href="#分段系统的基本原理" class="headerlink" title="分段系统的基本原理"></a>分段系统的基本原理</h3><ul>
<li><p>分段</p>
<p>  在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段定义了一组逻辑信息。例如，有主程序段MAIN、子程序段X、数据段D及栈段S等。每个段都有自己的名字。为了实现简单起见，通常可用一个段号来代替段名，每个段都从 0开始编址，并采用一段连续的地址空间。段的长度由相应的逻辑信息组的长度决定，因而各段长度不等。</p>
<p>  <img src="https://imgurl.org/temp/1809/f20be6dc547bcf0c.jpeg" alt="此处输入图片的描述"></p>
<p>  分段方式已得到许多编译程序的支持，<strong>编译程序</strong> 能自动地根据源程序的情况而产生若干个段。编译程序可以为全局变量、用于存储相应参数及返回地址的过程调用栈、每个过程或函数的代码部分、每个过程或函数的局部变量等等，分别建立各自的段。</p>
</li>
<li><p>段表</p>
<p>  在前面所介绍的动态分区分配方式中，系统为整个进程分配一个连续的内存空间。而在分段式存储管理系统中，则是为每个分段分配一个连续的分区，而进程中的各个段可以离散地移入内存中不同的分区中。为使程序能正常运行，亦即，能从物理内存中找出每个逻辑段所对应的位置，应像分页系统那样，在系统中为每个进程建立一张段映射表，简称“段表”。每个段在表中占有一个表项，其中记录了该段在内存中的<strong>起始地址(又称为“基址”)和段的长度</strong>。段表可以存放在一组寄存器中，这样有利于提高地址转换速度，但更常见的是将段表放在内存中</p>
<p>  <img src="https://imgurl.org/temp/1809/506390cfad51f3d7.jpeg" alt="此处输入图片的描述"></p>
</li>
<li><p>地址变换机构</p>
<p>  为了实现从进程的逻辑地址到物理地址的变换功能，在系统中设置了段表寄存器，用于存放段表始址和段表长度TL。在进行地址变换时，系统将逻辑地址中的段号与段表长度TL 进行比较。若S&gt;TL，表示段号太大，是访问越界，于是产生越界中断信号；若未越界，则根据段表的始址和该段的段号，计算出该段对应段表项的位置，从中读出该段在内存的起始地址，然后，再检查段内地址d是否超过该段的段长SL。若超过，即 d&gt;SL，同样发出越界中断信号；若未越界，则将该段的基址d与段内地址相加即可得到要访问的内存物理地址。</p>
<p>  <img src="https://imgurl.org/temp/1809/ed0def4a1147b823.jpeg" alt="此处输入图片的描述"></p>
<p>  像分页系统一样，当段表放在内存中时，每要访问一个数据，都须访问两次内存，从而极大地降低了计算机的速率。解决的方法也和分页系统类似，再增设一个联想存储器，用于保存最近常用的段表项。</p>
</li>
</ul>
<h3 id="分页和分段的主要区别"><a href="#分页和分段的主要区别" class="headerlink" title="分页和分段的主要区别"></a>分页和分段的主要区别</h3><ul>
<li><p>两者都采用离散分配方式，且都要通过地址映射机构来实现地址变换。</p>
</li>
<li><p>分页仅仅是由于系统管理的需要而不是用户的需要。段则是信息的逻辑单位，它含有一组其意义相对完整的信息</p>
</li>
<li><p>页的大小固定且由系统决定，由系统把逻辑地址划分为页号和页内地址两部分，是<br>由机器硬件实现的，因而在系统中只能有一种大小的页面；而段的长度却不固定，决定于用户所编写的程序，通常由编译程序在对源程序进行编译时，根据信息的性质来划分。</p>
</li>
<li><p>分页的作业地址空间是一维的，即单一的线性地址空间，程序员只需利用一个记忆<br>符，即可表示一个地址；而分段的作业地址空间则是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址</p>
</li>
</ul>
<h3 id="信息共享"><a href="#信息共享" class="headerlink" title="信息共享"></a>信息共享</h3><p>分段系统的一个突出优点，是易于实现段的共享，即允许若干个进程共享一个或多个分段，且对段的保护也十分简单易行。在分页系统中，虽然也能实现程序和数据的共享，但远不如分段系统来得方便。</p>
<blockquote>
<p>举个例子<br>有一个多用户系统，可同时接纳 40 个用户，他们都执行一个文本编辑程序(Text Editor)。如果文本编辑程序有 160 KB 的代码和另外 40 KB 的数据区，则总共需有 8 MB 的内存空间来支持 40个用户。如果160KB的代码是可重入的(Reentrant)，则无论是在分页系统还是在分段系统中，该代码都能被共享，在内存中只需保留一份文本编辑程序的副本，此时所需的内存空间仅为1760KB(40×40+160)，而不是8000KB。假定每个页面的大小为 4 KB，那么，160KB的代码将占用40个页面，数据区占10个页面。为实现代码的共享，应在每个进程的页表中都建立40个页表项，它们的物理块号都是21#～60#。在每个进程的页表中，还须为自己的数据区建立页表项，它们的物理块号分别是61#～70#、71#～80#、81#～90#，…，等等。</p>
</blockquote>
<p><img src="https://imgurl.org/temp/1809/63e9390247570b5f.jpeg" alt="此处输入图片的描述"></p>
<p>在分段系统中，实现共享则容易得多，只需在每个进程的段表中为文本编辑程序设置<br>一个段表项。</p>
<p><img src="https://imgurl.org/temp/1809/9b38a759d8b2b6e5.jpeg" alt="此处输入图片的描述"></p>
<h2 id="段页式存储管理方式"><a href="#段页式存储管理方式" class="headerlink" title="段页式存储管理方式"></a>段页式存储管理方式</h2><p>分页系统能有效地提高内存利用率，而分段系统则能很好地满足用户需要。如果能对两种存储管理方式“各取所长”，则可以将两者结合成一种新的存储管理方式系统。这种新系统既具有分段系统的便于实现、分段可共享、易于保护、可动态链接等一系列优点，又能像分页系统那样很好地解决内存的外部碎片问题，以及可为各个分段离散地分配内存等问题。把这种结合起来形成的新系统称为“段页式系统”。</p>
<ul>
<li><p>基本原理</p>
<p>  段页式系统的基本原理，是分段和分页原理的结合，即先将用户程序分成若干个段，再把每个段分成若干个页，并为每一个段赋予一个段名。</p>
</li>
<li><p>地址变换过程</p>
<p>  在段页式系统中，为了便于实现地址变换，须配置一个段表寄存器，其中存放段表始址和段表长 TL。进行地址变换时，首先利用段号 S，将它与段表长 TL进行比较。若 S &lt; TL，表示未越界，于是利用段表始址和段号来求出该段所对应的段表项在段表中的位置，从中得到该段的页表始址，并利用逻辑地址中的段内页号P来获得对应页的页表项位置，从中读出该页所在的物理块号b，再利用块号b和页内地址来构成物理地址。</p>
<p>  在段页式系统中，为了获得一条指令或数据，须三次访问内存。第一次访问是访问内存中的段表，从中取得页表始址；第二次访问是访问内存中的页表，从中取出该页所在的物理块号，并将该块号与页内地址一起形成指令或数据的物理地址；第三次访问才是真正从第二次访问所得的地址中，取出指令或数据。显然，这使访问内存的次数增加了近两倍。为了提高执行速度，在地址变换机构中增设一个高速缓冲寄存器。每次访问它时，都须同时利用段号和页号去检索高速缓存，若找到匹配的表项，便可从中得到相应页的物理块号，用来与页内地址一起形成物理地址；若未找到匹配表项，则仍须再三次访问内存。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/02/2018-09-02-对换/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="嘿嘿嘿">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://s2.ax1x.com/2019/08/14/mFInYj.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/02/2018-09-02-对换/" itemprop="url">对换</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-02T00:00:00+08:00">
                2018-09-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  634
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  2
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="对换"><a href="#对换" class="headerlink" title="对换"></a>对换</h3><ul>
<li><p>对换(Swapping)的引入</p>
<p>  在多道程序环境下，一方面，在内存中的某些进程由于某事件尚未发生而被阻塞运行，但它却占用了大量的内存空间，甚至有时可能出现在内存中所有进程都被阻塞而迫使CPU停止下来等待的情况；另一方面，却又有着许多作业在外存上等待，因无内存而不能入内存运行的情况。显然这对系统资源是一种严重的浪费，且使系统吞吐量下降。为了解决这一问题，在系统中又增设了对换(也称交换)设施。所谓“对换”，是指把内存中暂时不能运行的进程或者暂时不用的程序和数据调出到外存上，以便腾出足够的内存空间，再把已具备运行条件的进程或进程所需要的程序和数据调入内存。对换是提高内存利用率的有效措施。</p>
<p>  如果对换是以整个进程为单位的，便称之为“整体对换”或“进程对换”。而如果对换是以“页”或“段”为单位进行的，则分别称之为“页面对换”或“分段对换”，又统称为“部分对换”。</p>
</li>
<li><p>实现进程对换，系统必须能实现三方面的功能</p>
<ul>
<li><p>对换空间的管理</p>
<p>  在具有对换功能的OS中，通常把外存分为文件区和对换区。前者用于存放文件，后者用于存放从内存换出的进程。</p>
</li>
<li><p>进程的换出</p>
<p>   每当一进程由于创建子进程而需要更多的内存空间，但又无足够的内存空间等情况发生时，系统应将某进程换出。其过程是：系统首先选择处于阻塞状态且优先级最低的进程作为换出进程，然后启动磁盘，将该进程的程序和数据传送到磁盘的对换区上。若传送过程未出现错误，便可回收该进程所占用的内存空间，并对该进程的进程控制块做相应的修改。</p>
</li>
<li><p>进程的换入</p>
<p> 系统应定时地查看所有进程的状态，从中找出“就绪”状态但已换出的进程，将其中换出时间最久(换出到磁盘上)的进程作为换入进程，将之换入，直至已无可换入的进程或无可换出的进程为止。</p>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/02/2018-09-02-经典进程的同步问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="嘿嘿嘿">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://s2.ax1x.com/2019/08/14/mFInYj.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/02/2018-09-02-经典进程的同步问题/" itemprop="url">经典进程的同步问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-02T00:00:00+08:00">
                2018-09-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  695
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="经典进程的同步问题"><a href="#经典进程的同步问题" class="headerlink" title="经典进程的同步问题"></a>经典进程的同步问题</h2><h3 id="生产者—消费者问题"><a href="#生产者—消费者问题" class="headerlink" title="生产者—消费者问题"></a>生产者—消费者问题</h3><ul>
<li><p>利用记录型信号量解决</p>
<p>  假定在生产者和消费者之间的公用缓冲池中，具有n个缓冲区，这时可利用互斥信号量mutex实现诸进程对缓冲池的互斥使用。利用信号量emptyCount和fullCount分别表示缓冲池中 <code>空缓冲区</code> 和 <code>满缓冲区</code> 的数量</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mutex, emptyCount, fullCount := 1, n, 0</span><br><span class="line"></span><br><span class="line">func proceducer() &#123;</span><br><span class="line">    wait(emptyCount)</span><br><span class="line">    wait(mutex)</span><br><span class="line"></span><br><span class="line">    // 生产一个产品，放入一个空的缓冲区中</span><br><span class="line"></span><br><span class="line">    signal(mutex)</span><br><span class="line">    signal(fullCount)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func consumer() &#123;</span><br><span class="line">    wait(fullCount)</span><br><span class="line">    wait(mutex)；</span><br><span class="line"></span><br><span class="line">    // 消费一个产品，取走一个满缓冲区的内容</span><br><span class="line"></span><br><span class="line">    signal(mutex)；</span><br><span class="line">    signal(emptyCount)；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用 AND 信号量解决</p>
<p>  对于生产者—消费者问题，也可利用AND信号量来解决，即用 <code>Swait(empty，mutex)</code> 来代替 <code>wait(empty)</code> 和 <code>wait(mutex)</code>；用 <code>Ssignal(mutex，full)</code> 来代替 <code>signal(mutex)</code> 和 <code>signal(full)</code> ；用 <code>Swait(full，mutex)</code> 来代替 <code>wait(full)</code> 和 <code>wait(mutex)</code>，以及用 <code>Ssignal(mutex，empty)</code> 代替 <code>Signal(mutex)</code> 和 <code>Signal(empty)</code>。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mutex, emptyCount, fullCount := 1, n, 0</span><br><span class="line"></span><br><span class="line">func proceducer() &#123;</span><br><span class="line">    Swait(emptyCount, mutex)</span><br><span class="line">    // 生产一个产品，放入一个空的缓冲区中</span><br><span class="line">    Ssignal(mutex，fullCount)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func consumer() &#123;</span><br><span class="line">    Swait(fullCount，mutex)</span><br><span class="line">    // 消费一个产品，取走一个满缓冲区的内容</span><br><span class="line">    Ssignal(mutex，emptyCount)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用管程解决</p>
<p>  在利用管程方法来解决生产者—消费者问题时，首先便是为它们建立一个管程，并命名为 ProclucerConsumer，或简称为 PC。其中包括两个过程：</p>
<ul>
<li><p>put(item)过程。生产者利用该过程将自己生产的产品投放到缓冲池中，并用整型变量 count 来表示在缓冲池中已有的产品数目，当 count≥n 时，表示缓冲池已满，生产者须等待。</p>
</li>
<li><p>get(item)过程。消费者利用该过程从缓冲池中取出一个产品，当 count≤0 时，表示缓冲池中已无可取用的产品，消费者应等待</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">var notfull，notempty condition</span><br><span class="line"></span><br><span class="line">type condition struct &#123;</span><br><span class="line">    queue []processes</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *condition) wait() &#123;&#125;</span><br><span class="line">func (c *condition) signal() &#123;&#125;</span><br><span class="line"></span><br><span class="line">type ProclucerConsumer struct &#123;</span><br><span class="line">    buffer make([]int, count)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (pc *ProclucerConsumer) put(item int) &#123;</span><br><span class="line">    if count &gt;= len(pc.buffer) &#123;</span><br><span class="line">        // 等待非满信号</span><br><span class="line">        notfull.wait()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pc.buffer = pc.buffer.append(item)</span><br><span class="line"></span><br><span class="line">    // 在非空队列有进程等待时，唤醒一个等待的进程</span><br><span class="line">    if len(notempty.queue) &gt; 0 &#123;</span><br><span class="line">        notempty.signal()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (pc *ProclucerConsumer) get() int &#123;</span><br><span class="line">    if count &lt;= 0 &#123;</span><br><span class="line">        // 等待非空信号</span><br><span class="line">        notEmpty.wait()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    item = pc.buffer[-1]</span><br><span class="line"></span><br><span class="line">    if len(notFull.queue) &gt; 0 &#123;</span><br><span class="line">        notFull.signal()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return item</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h3><ul>
<li><p>利用 AND 信号量机制解决</p>
<p>  当哲学家饥饿时，总是先去拿他左边的筷子，即执行 wait(chopstick[i])；成功后，再去拿他右边的筷子，即执行 wait(chopstick[(i+1)mod 5])</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Var chopsiick array of semaphore := (1, 1, 1, 1, 1)；</span><br><span class="line">processi</span><br><span class="line">    repeat</span><br><span class="line">        think；</span><br><span class="line">        Sswait(chopstick[(i+1) mod 5]，chopstick[i])；</span><br><span class="line">        eat；</span><br><span class="line">        Ssignat(chopstick[(i+1) mod 5]，chopstick[i])；</span><br><span class="line">    until false；</span><br></pre></td></tr></table></figure>

</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/02/2018-09-02-线程的基本概念/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="嘿嘿嘿">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://s2.ax1x.com/2019/08/14/mFInYj.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/02/2018-09-02-线程的基本概念/" itemprop="url">线程的基本概念</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-02T00:00:00+08:00">
                2018-09-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4.4k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  14
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="线程的基本概念"><a href="#线程的基本概念" class="headerlink" title="线程的基本概念"></a>线程的基本概念</h2><h3 id="线程的引入"><a href="#线程的引入" class="headerlink" title="线程的引入"></a>线程的引入</h3><p>如果说，在操作系统中引入进程的目的，是为了使多个程序能并发执行，以提高资源利用率和系统吞吐量，那么，在操作系统中再引入线程，则是为了减少程序在并发执行时所付出的时空开销，使 OS 具有更好的并发性。</p>
<p>由于进程是一个资源的拥有者，因而在创建、撤消和切换中，系统必须为之付出较大的时空开销。线程作为调度和分派的基本单位。</p>
<h3 id="线程与进程的比较"><a href="#线程与进程的比较" class="headerlink" title="线程与进程的比较"></a>线程与进程的比较</h3><p>线程具有许多传统进程所具有的特征，所以又称为轻型进程(Light-Weight Process)或进程元，相应地把传统进程称为重型进程(Heavy-WeightProcess)</p>
<ul>
<li>调度</li>
</ul>
<p>在传统的操作系统中，作为拥有资源的基本单位和独立调度、分派的基本单位都是进程。而在引入线程的操作系统中，则把线程作为调度和分派的基本单位，而进程作为资源拥有的基本单位，使线程基本上不拥有资源，这样线程便能轻装前进，从而可显著地提高系统的并发程度。在同一进程中，线程的切换不会引起进程的切换，但从一个进程中的线程切换到另一个进程中的线程时，将会引起进程的切换。</p>
<ul>
<li><p>并发性</p>
<p>  在引入线程的操作系统中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间亦可并发执行，使得操作系统具有更好的并发性，从而能更加有效地提高系统资源的利用率和系统的吞吐量</p>
</li>
<li><p>拥有资源</p>
<p>  进程是系统中拥有资源的一个基本单位。一般而言，线程自己不拥有系统资源(也有一点必不可少的资源)，但它可以访问其隶属进程的资源，即一个进程的代码段、数据段及所拥有的系统资源，如已打开的文件、I/O设备等，可以供该进程中的所有线程所共享。</p>
</li>
<li><p>系统开销</p>
<p>  在创建或撤消进程时，系统都要为之创建和回收进程控制块，分配或回收资源，如内存空间和I/O设备等，操作系统所付出的开销明显大于线程创建或撤消时的开销。类似地，在进程切换时，涉及到当前进程CPU环境的保存及新被调度运行进程的CPU环境的设置，而线程的切换则仅需保存和设置少量寄存器内容，不涉及存储器管理方面的操作，所以就切换代价而言，进程也是远高于线程的。此外，由于一个进程中的多个线程具有相同的地址空间，在同步和通信的实现方面线程也比进程容易。在一些操作系统中，线程的切换、同步和通信都无须操作系统内核的干预。</p>
</li>
</ul>
<h3 id="线程的属性"><a href="#线程的属性" class="headerlink" title="线程的属性"></a>线程的属性</h3><ul>
<li><p>轻型实体</p>
<p>  线程中的实体基本上不拥有系统资源，只是有一点必不可少的、能保证其独立运行的资源，比如，在每个线程中都应具有一个用于控制线程运行的线程控制块 <code>TCB</code>，用于指示被执行指令序列的程序计数器，保留局部变量、少数状态参数和返回地址等的一组寄存器和堆栈。</p>
</li>
<li><p>独立调度和分派的基本单位</p>
</li>
<li><p>可并发执行</p>
</li>
<li><p>共享进程资源</p>
</li>
</ul>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><ul>
<li><p>状态参数</p>
<p>  在 OS 中的每一个线程都可以利用线程标识符和一组状态参数进行描述。状态参数通常有这样几项：</p>
<ul>
<li><p>寄存器状态，它包括程序计数器 PC（存放下一条指令所在单元） 和堆栈指针中的内容；</p>
</li>
<li><p>堆栈，在堆栈中通常保存有局部变量和返回地址；</p>
</li>
<li><p>线程运行状态，用于描述线程正处于何种运行状态；</p>
</li>
<li><p>优先级，描述线程执行的优先程度；</p>
</li>
<li><p>线程专有存储器，用于保存线程自己的局部变量拷贝；</p>
</li>
<li><p>信号屏蔽，即对某些信号加以屏蔽。</p>
</li>
</ul>
</li>
<li><p>线程运行状态</p>
<ul>
<li><p>执行状态</p>
<p>  表示线程正获得处理机而运行；</p>
</li>
<li><p>就绪状态</p>
<p>  指线程已具备了各种执行条件，一旦获得 CPU 便可执行的状态；</p>
</li>
<li><p>阻塞状态</p>
<p>  指线程在执行中因某事件而受阻，处于暂停执行时的状态。</p>
</li>
</ul>
</li>
</ul>
<h3 id="线程的创建和终止"><a href="#线程的创建和终止" class="headerlink" title="线程的创建和终止"></a>线程的创建和终止</h3><p>在多线程 OS 环境下，应用程序在启动时，通常仅有一个“初始化线程”在执行。它可根据需要再去创建若干个线程。</p>
<ul>
<li><p>创建新线程</p>
<ul>
<li>调用线程创建函数</li>
<li>提供相应的参数，如指向线程主程序的入口指针、堆栈的大小，以及用于调度的优先级等</li>
<li>返回一个线程标识符</li>
</ul>
</li>
<li><p>终止线程</p>
<ul>
<li><p>在线程完成了自己的工作后自愿退出</p>
</li>
<li><p>在运行中出现错误或由于某种原因而被其它线程强行终止</p>
</li>
<li><p>线程被中止后并不立即释放它所占有的资源，只有当进程中的其它线程执行了 <code>分离函数</code> 后，被终止的线程才与资源分离，此时的资源才能被其它线程利用</p>
</li>
<li><p>虽已被终止但尚未释放资源的线程，仍可以被需要它的线程所调用，以使被终止线程重新恢复运行。为此，调用者线程须调用一条被称为“等待线程终止”的连接命令，来与该线程进行连接。如果在一个调用者线程调用“等待线程终止”的连接命令试图与指定线程相连接时，若指定线程尚未被终止，则调用连接命令的线程将会阻塞，直至指定线程被终止后才能实现它与调用者线程的连接并继续执行；若指定线程已被终止，则调用者线程不会被阻塞而是继续执行。</p>
</li>
</ul>
</li>
</ul>
<h3 id="线程间的同步和通信"><a href="#线程间的同步和通信" class="headerlink" title="线程间的同步和通信"></a>线程间的同步和通信</h3><ul>
<li><p>互斥锁(mutex)</p>
<p>  互斥锁是一种比较简单的、用于实现线程间对资源互斥访问的机制。由于操作互斥锁的时间和空间开销都较低，因而较适合于高频度使用的关键共享数据和程序段。互斥锁可以有两种状态，即开锁(unlock)和关锁(lock)状态。相应地，可用两条命令(函数)对互斥锁进行操作。其中的关锁 lock 操作用于将 mutex 关上，开锁操作 unlock 则用于打开 mutex。</p>
</li>
<li><p>条件变量</p>
<p>  线程首先对 mutex执行关锁操作，若成功便进入临界区，然后查找用于描述该资源状态的数据结构，以了解资源的情况。只要发现所需资源R正处于忙碌状态，线程便转为等待状态，<strong>并对mutex执行开锁操作后</strong> ，等待该资源被释放；若资源处于空闲状态，表明线程可以使用该资源，于是 <strong>将该资源设置为忙碌状态</strong>，再对 mutex执行开锁操作。下面给出了对上述资源的申请(左半部分)和释放(右半部分)操作的描述。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Lock mutex</span><br><span class="line">    check data structures；</span><br><span class="line">    if (resource busy)</span><br><span class="line">        wait(condition variable)；</span><br><span class="line">    mark resource as busy；</span><br><span class="line">unlock mutex；</span><br><span class="line"></span><br><span class="line">Lock mutex</span><br><span class="line">mark resource as free；</span><br><span class="line">unlock mutex；</span><br><span class="line">wakeup(condition variable)；</span><br></pre></td></tr></table></figure>

<p>  原来占有资源 R 的线程在使用完该资源后，便按照右半部分的描述释放该资源，其中的 wakeup(conditionvariable)表示去唤醒在指定条件变量上等待的一个或多个线程。在大多数情况下，由于所释放的是临界资源，此时所唤醒的只能是在条件变量上等待的某一个线程，其它线程仍继续在该队列上等待。但如果线程所释放的是一个数据文件，该文件允许多个线程同时对它执行读操作。在这种情况下，当一个写线程完成写操作并释放该文件后，如果此时在该条件变量上还有多个读线程在等待，则该线程可以唤醒所有的等待线程。</p>
</li>
</ul>
<h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><ul>
<li><p>私用信号量</p>
<p>  当某线程需利用信号量来实现同一进程中各线程之间的同步时，可调用创建信号量的命令来创建一私用信号量，其数据结构存放在应用程序的地址空间中。私用信号量属于特定的进程所有，OS并不知道私用信号量的存在，因此，一旦发生私用信号量的占用者异常结束或正常结束，但并未释放该信号量所占有空间的情况时，系统将无法使它恢复为0(空)，也不能将它传送给下一个请求它的线程。</p>
</li>
<li><p>公用信号量</p>
<p>  公用信号量是为实现不同进程间或不同进程中各线程之间的同步而设置的。由于它有着一个公开的名字供所有的进程使用，故而把它称为公用信号量。其数据结构是存放在受保护的系统存储区中，由OS为它分配空间并进行管理，故也称为系统信号量。如果信号量的占有者在结束时未释放该公用信号量，则 OS 会自动将该信号量空间回收，并通知下一进程。</p>
</li>
</ul>
<h3 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h3><ul>
<li><p>内核支持线程</p>
<p>  无论是用户进程中的线程，还是系统进程中的线程，他们的创建、撤消和切换等也是依靠内核，在内核空间实现的。此外，在内核空间还为每一个内核支持线程设置了一个线程控制块，内核是根据该控制块而感知某线程的存在，并对其加以控制。</p>
<p>  这种线程实现方式主要有如下四个优点：</p>
<ul>
<li><p>在多处理器系统中，内核能够同时调度同一进程中多个线程并行执行；</p>
</li>
<li><p>如果进程中的一个线程被阻塞了，内核可以调度该进程中的其它线程占有处理器运行，也可以运行其它进程中的线程；</p>
</li>
<li><p>内核支持线程具有很小的数据结构和堆栈，线程的切换比较快，切换开销小；</p>
</li>
<li><p>内核本身也可以采用多线程技术，可以提高系统的执行速度和效率。</p>
<p>内核支持线程的主要缺点是：</p>
</li>
<li><p>对于用户的线程切换而言，其模式切换的开销较大，在同一个进程中，从一个线程切换到另一个线程时，需要从用户态转到内核态进行，这是因为用户进程的线程在用户态运行，而线程调度和管理是在内核实现的，系统开销较大</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>用户级线程</p>
<p>  用户级线程 ULT(User Level Threads)仅存在于用户空间中。对于这种线程的创建、撤消、线程之间的同步与通信等功能，都无须利用系统调用来实现。对于用户级线程的切换，通常发生在一个应用进程的诸多线程之间，这时，也同样无须内核的支持。由于切换的规则远比进程调度和切换的规则简单，因而使线程的切换速度特别快。</p>
</li>
</ul>
<h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><ul>
<li><p>内核支持线程的实现</p>
<p>  在仅设置了内核支持线程的OS中，一种可能的线程控制方法是，系统在创建一个新进程时，便为它分配一个任务数据区 PTDA(Per Task Data Area)，其中包括若干个线程控制块TCB 空间。在每一个 TCB 中可保存线程标识符、优先级、线程运行的CPU状态等信息。虽然这些信息与用户级线程 TCB 中的信息相同，但现在却是被保存在内核空间中。</p>
<p>  每当进程要创建一个线程时，便为新线程分配一个TCB，将有关信息填入该 TCB 中，并为之分配必要的资源，如为线程分配数百至数千个字节的栈空间和局部存储区，于是新创建的线程便有条件立即执行。当 PTDA中的所有 TCB 空间已用完，而进程又要创建新的线程时，只要其所创建的线程数目未超过系统的允许值(通常为数十至数百个)，系统可再为之分配新的 TCB 空间；在撤消一个线程时，也应回收该线程的所有资源和TCB。可见，内核支持线程的创建、 撤消均与进程的相类似。在有的系统中为了减少创建和撤消一个线程时的开销，在撤消一个线程时，并不立即回收该线程的资源和 TCB，当以后再要创建一个新线程时，便可直接利用已被撤消但仍保持有资源和 TCB 的线程作为新线程。</p>
</li>
<li><p>用户级线程的实现</p>
<p>  用户级线程是在用户空间实现的。所有的用户级线程都具有相同的结构，它们都运行在一个中间系统的上面。当前有两种方式实现的中间系统，即运行时系统和内核控制线程。</p>
<ul>
<li><p>运行时系统(Runtime System)</p>
<p>  所谓“运行时系统”，实质上是用于管理和控制线程的函数(过程)的集合，其中包括用于创建和撤消线程的函数、线程同步和通信的函数以及实现线程调度的函数等。正因为有这些函数，才能使用户级线程与内核无关。运行时系统中的所有函数都驻留在用户空间，并作为用户级线程与内核之间的接口。</p>
<p>  在传统的 OS 中，进程在切换时必须先由用户态转为核心态，再由核心来执行切换任务；而用户级线程在切换时则不需转入核心态，而是由运行时系统中的线程切换过程来执行切换任务。该过程将线程的CPU状态保存在该线程的堆栈中，然后按照一定的算法选择一个处于就绪状态的新线程运行，将新线程堆栈中的 CPU 状态装入到CPU相应的寄存器中，一旦将栈指针和程序计数器切换后，便开始了新线程的运行。由于用户级线程的切换无需进入内核，且切换操作简单，因而使用户级线程的切换速度非常快。</p>
<p>  不论在传统的 OS 中，还是在多线程OS中，系统资源都是由内核管理的。在传统的OS 中，进程是利用OS提供的系统调用来请求系统资源的，系统调用通过软中断(如 trap)机制进入OS内核，由内核来完成相应资源的分配。用户级线程是不能利用系统调用的。当线程需要系统资源时，是将该要求传送给运行时系统，由后者通过相应的系统调用来获得系统资源的。</p>
</li>
<li><p>内核控制线程</p>
<p>  这种线程又称为轻型进程 LWP(Light Weight Process)。每一个进程都可拥有多个 LWP，同用户级线程一样，每个 LWP 都有自己的数据结构(如TCB)，其中包括线程标识符、优先级、状态，另外还有栈和局部存储区等。它们也可以共享进程所拥有的资源。LWP可通过系统调用来获得内核提供的服务，这样，当一个用户级线程运行时，只要将它连接到一个LWP 上，此时它便具有了内核支持线程的所有属性。这种线程实现方式就是组合方式。</p>
<p>  在一个系统中的用户级线程数量可能很大，为了节省系统开销，不可能设置太多的LWP，而把这些LWP做成一个缓冲池，称为“线程池”。用户进程中的任一用户线程都可以连接到 LWP 池中的任何一个 LWP 上。为使每一用户级线程都能利用LWP与内核通信，可以使多个用户级线程多路复用一个 LWP，但只有当前连接到LWP上的线程才能与内核通信，其余进程或者阻塞，或者等待 LWP。而每一个 LWP 都要连接到一个内核级线程上，这<br>样，通过 LWP 可把用户级线程与内核线程连接起来，用户级线程可通过 LWP 来访问内核，但内核所看到的总是多个 LWP 而看不到用户级线程。亦即，由 LWP 实现了在内核与用户级线程之间的隔离，从而使用户级线程与内核无关。</p>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="https://s2.ax1x.com/2019/08/14/mFInYj.jpg" alt="嘿嘿嘿">
            
              <p class="site-author-name" itemprop="name">嘿嘿嘿</p>
              <p class="site-description motion-element" itemprop="description">记录打怪升级之路</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yourname" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yourname@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">嘿嘿嘿</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
